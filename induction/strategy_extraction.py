
import json
import re
import codecs
import copy
import argparse
import pickle as pkl
from tqdm import tqdm
from multiprocessing import Pool

import time
import random
import os
import re


random.seed(42)

combined_lines = []
pattern = r'\((.*?)\)'

openai.api_key = ""
enc = tiktoken.encoding_for_model("")
API_MAX_RETRY = 16
API_RETRY_SLEEP = 10
API_ERROR_OUTPUT = "$ERROR$"

def get_result(i, json_content):
    for _ in range(API_MAX_RETRY):
        try:
            message=[{"role": "user", "content": json_content}]
            response = openai.ChatCompletion.create(
                model="gpt-4",
                messages=message,
                temperature=0,
                frequency_penalty=0.6,
            )
            output = response["choices"][0]["message"]["content"]
            break
        except openai.error.OpenAIError as e:
            print(type(e), e)
            time.sleep(API_RETRY_SLEEP)
    return output


def process_data_en(args):
    data_list = []
    result_data_list = []
    p = Pool(processes=200)

    with open(args.data_path, "r", encoding="UTF-8") as file:
        datas = file.readlines()
    
    print(len(datas))
    for idx, data in enumerate(random_datas):
        turns = []
        data = json.loads(data)
        questions = [turn for turn in data["conversations"] if turn["from"] == "human"]
        answers = [turn for turn in data["conversations"] if turn["from"] == "gpt"]
        if len(answers) != len(questions):
            continue
        dialogue_history = ""
        for i in range(len(questions)-1):
            # 实际
            dialogue_history = answers[i]["value"]
            # 论文中
            dialogue_history += "user: {}".format(questions[i])
            dialogue_history += "user: {}".format(answers[i])

            question = questions[i+1]["value"]
            turns = data["conversations"][:2*i + 2]
            prompt = "You are very good at learning from real-human dialogues about how they generate high-quality instructions. The dialogue history is: {}. The next instruction generated by the human is: {}. \
                    Please analyze why humans generate such instruction based on the above dialogue history, and give the instructional strategy you have learned. \
                    Good instructional strategies need to meet the following requirements: \
                    (1) Instructional strategies should be expressed in simple phrases; \
                    (2) Instructional strategies should not include specific information from the dialogue history. \
                    To better assist you in inducing instructional strategies, I will provide you with some examples: \
                    (1) Explore possibilities and propose hypotheses; \
                    (2) Provide detailed information and seek specific solutions; \
                    (3) Dig deep into details. \
                    These examples are used to help you clarify the expression form of instructional strategies, which are not entirely effective instructional strategies. You need to induce them yourself. \
                    Finally, please output in the following format: \{``analysis'': xxx, ``strategy'': xxx\}, where ”analysis” is the reason why humans generate such instruction based on the dialogue history, and ”strategy” is just one induced instructional strategy. The expression should be concise, with no more than 20 words. Now please start thinking seriously. The results of your thinking are very important to me. ".format(dialogue_history, question)
            result_data_list.append((data["idx"], turns, question, p.apply_async(get_result, args=(i, prompt))))
    print('len(result_data_list',len(result_data_list))

    
    count = 0
    flag = 1
    id_set = set()
    while flag:
        for id, process in enumerate(result_data_list):
            if process[3].ready() and id not in id_set:
                count += 1
                if count % 100 == 0:
                    print('count = ', count)
                id_set.add(id)
                result_data = process[3].get()
                try:
                    pattern1 = r"(?i)analysis"
                    if result_data is not None:
                        matches = re.split(pattern1, result_data)
                        pattern2 = r"(?i)strategy|(?i)strategies"
                        split_result_1 = re.split(pattern2, matches[1], re.IGNORECASE) if len(matches)== 2 else re.split(pattern2, matches[0], re.IGNORECASE)
                        analysis = split_result_1[0][1:]
                        split_result_2 = re.split(pattern2, result_data, re.IGNORECASE)
                        skill = split_result_2[1] if len(split_result_2) == 2 else split_result_2[0]
                        turns_new = process[1].copy()
                        value = "【instructional strategy】{}【instruction】{}".format(skill[1:].lstrip(), process[2])
                        turns_new.append({"from":"human", "value":value})
                        data = {
                            "idx":process[0],
                            "conversations":turns_new
                        }
                        with open(args.save_path, 'a', encoding='utf-8') as jsonfile:
                            jsonfile.write(json.dumps(data, ensure_ascii=False) + "\n")
                except json.JSONDecodeError as e:
                    print(f"Error decoding JSON: {result_data}")
            if count == len(result_data_list):
                flag = 0
                break
    p.close()
    p.join()

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--data_path", type=str, default="") 
    parser.add_argument("--save_path", type=str, default="")  
    args = parser.parse_args()
    process_data_en(args)
